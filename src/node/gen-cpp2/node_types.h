/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/GeneratedHeaderHelper.h>
#include <thrift/lib/cpp2/Thrift.h>
#include <thrift/lib/cpp2/protocol/Protocol.h>


// BEGIN declare_enums

// END declare_enums
// BEGIN struct_indirection

// END struct_indirection
// BEGIN forward_declare
namespace node { namespace cpp2 {
class ErrorStruct;
class Transaction;
class SendTransactionRequest;
class SendTransactionResponse;
class NotifyNewInventoryRequest;
class NotifyNewInventoryResponse;
class GetPeerInfoRequest;
class GetPeerInfoResponse;
}} // node::cpp2
// END forward_declare
// BEGIN typedefs

// END typedefs
// BEGIN hash_and_equal_to
// END hash_and_equal_to
namespace node { namespace cpp2 {
class ErrorStruct final : private apache::thrift::detail::st::ComparisonOperators<ErrorStruct> {
 public:

  ErrorStruct() :
      code(static_cast<int8_t>(0)) {}
  // FragileConstructor for use in initialization lists only.
  ErrorStruct(apache::thrift::FragileConstructor, int8_t code__arg, std::string message__arg);
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  ErrorStruct(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    ErrorStruct(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    code = arg.move();
    __isset.code = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  ErrorStruct(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    ErrorStruct(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    message = arg.move();
    __isset.message = true;
  }

  ErrorStruct(ErrorStruct&&) = default;

  ErrorStruct(const ErrorStruct&) = default;

  ErrorStruct& operator=(ErrorStruct&&) = default;

  ErrorStruct& operator=(const ErrorStruct&) = default;
  void __clear();
  int8_t code;
  std::string message;

  struct __isset {
    bool code;
    bool message;
  } __isset = {};
  bool operator==(const ErrorStruct& rhs) const;

  bool operator < (const ErrorStruct& rhs) const {
    if (!(code == rhs.code)) {
      return code < rhs.code;
    }
    if (!(message == rhs.message)) {
      return message < rhs.message;
    }
    (void)rhs;
    return false;
  }

  int8_t get_code() const {
    return code;
  }

  int8_t& set_code(int8_t code_) {
    code = code_;
    __isset.code = true;
    return code;
  }

  const std::string& get_message() const& {
    return message;
  }

  std::string get_message() && {
    return std::move(message);
  }

  template <typename T_ErrorStruct_message_struct_setter = std::string>
  std::string& set_message(T_ErrorStruct_message_struct_setter&& message_) {
    message = std::forward<T_ErrorStruct_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  static void translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype);

  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ErrorStruct >;
};

void swap(ErrorStruct& a, ErrorStruct& b);
extern template void ErrorStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t ErrorStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t ErrorStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t ErrorStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void ErrorStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t ErrorStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t ErrorStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t ErrorStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

template <class Protocol_>
uint32_t ErrorStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}} // node::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::node::cpp2::ErrorStruct>::clear( ::node::cpp2::ErrorStruct* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::node::cpp2::ErrorStruct>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::node::cpp2::ErrorStruct>::write(Protocol* proto,  ::node::cpp2::ErrorStruct const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> void Cpp2Ops< ::node::cpp2::ErrorStruct>::read(Protocol* proto,  ::node::cpp2::ErrorStruct* obj) {
  return obj->readNoXfer(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::node::cpp2::ErrorStruct>::serializedSize(Protocol const* proto,  ::node::cpp2::ErrorStruct const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::node::cpp2::ErrorStruct>::serializedSizeZC(Protocol const* proto,  ::node::cpp2::ErrorStruct const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace node { namespace cpp2 {
class Transaction final : private apache::thrift::detail::st::ComparisonOperators<Transaction> {
 public:

  Transaction() :
      amount(0),
      timestamp(0) {}
  // FragileConstructor for use in initialization lists only.
  Transaction(apache::thrift::FragileConstructor, std::string sending_wallet_id__arg, std::string receiving_wallet_id__arg, int64_t amount__arg, int64_t timestamp__arg);
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Transaction(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Transaction(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    sending_wallet_id = arg.move();
    __isset.sending_wallet_id = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Transaction(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Transaction(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    receiving_wallet_id = arg.move();
    __isset.receiving_wallet_id = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Transaction(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Transaction(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    amount = arg.move();
    __isset.amount = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  Transaction(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    Transaction(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    timestamp = arg.move();
    __isset.timestamp = true;
  }

  Transaction(Transaction&&) = default;

  Transaction(const Transaction&) = default;

  Transaction& operator=(Transaction&&) = default;

  Transaction& operator=(const Transaction&) = default;
  void __clear();
  std::string sending_wallet_id;
  std::string receiving_wallet_id;
  int64_t amount;
  int64_t timestamp;

  struct __isset {
    bool sending_wallet_id;
    bool receiving_wallet_id;
    bool amount;
    bool timestamp;
  } __isset = {};
  bool operator==(const Transaction& rhs) const;

  bool operator < (const Transaction& rhs) const {
    if (!(sending_wallet_id == rhs.sending_wallet_id)) {
      return sending_wallet_id < rhs.sending_wallet_id;
    }
    if (!(receiving_wallet_id == rhs.receiving_wallet_id)) {
      return receiving_wallet_id < rhs.receiving_wallet_id;
    }
    if (!(amount == rhs.amount)) {
      return amount < rhs.amount;
    }
    if (!(timestamp == rhs.timestamp)) {
      return timestamp < rhs.timestamp;
    }
    (void)rhs;
    return false;
  }

  const std::string& get_sending_wallet_id() const& {
    return sending_wallet_id;
  }

  std::string get_sending_wallet_id() && {
    return std::move(sending_wallet_id);
  }

  template <typename T_Transaction_sending_wallet_id_struct_setter = std::string>
  std::string& set_sending_wallet_id(T_Transaction_sending_wallet_id_struct_setter&& sending_wallet_id_) {
    sending_wallet_id = std::forward<T_Transaction_sending_wallet_id_struct_setter>(sending_wallet_id_);
    __isset.sending_wallet_id = true;
    return sending_wallet_id;
  }

  const std::string& get_receiving_wallet_id() const& {
    return receiving_wallet_id;
  }

  std::string get_receiving_wallet_id() && {
    return std::move(receiving_wallet_id);
  }

  template <typename T_Transaction_receiving_wallet_id_struct_setter = std::string>
  std::string& set_receiving_wallet_id(T_Transaction_receiving_wallet_id_struct_setter&& receiving_wallet_id_) {
    receiving_wallet_id = std::forward<T_Transaction_receiving_wallet_id_struct_setter>(receiving_wallet_id_);
    __isset.receiving_wallet_id = true;
    return receiving_wallet_id;
  }

  int64_t get_amount() const {
    return amount;
  }

  int64_t& set_amount(int64_t amount_) {
    amount = amount_;
    __isset.amount = true;
    return amount;
  }

  int64_t get_timestamp() const {
    return timestamp;
  }

  int64_t& set_timestamp(int64_t timestamp_) {
    timestamp = timestamp_;
    __isset.timestamp = true;
    return timestamp;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  static void translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype);

  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Transaction >;
};

void swap(Transaction& a, Transaction& b);
extern template void Transaction::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t Transaction::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t Transaction::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t Transaction::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void Transaction::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t Transaction::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t Transaction::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t Transaction::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

template <class Protocol_>
uint32_t Transaction::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}} // node::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::node::cpp2::Transaction>::clear( ::node::cpp2::Transaction* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::node::cpp2::Transaction>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::node::cpp2::Transaction>::write(Protocol* proto,  ::node::cpp2::Transaction const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> void Cpp2Ops< ::node::cpp2::Transaction>::read(Protocol* proto,  ::node::cpp2::Transaction* obj) {
  return obj->readNoXfer(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::node::cpp2::Transaction>::serializedSize(Protocol const* proto,  ::node::cpp2::Transaction const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::node::cpp2::Transaction>::serializedSizeZC(Protocol const* proto,  ::node::cpp2::Transaction const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace node { namespace cpp2 {
class SendTransactionRequest final : private apache::thrift::detail::st::ComparisonOperators<SendTransactionRequest> {
 public:

  SendTransactionRequest() {}
  // FragileConstructor for use in initialization lists only.
  SendTransactionRequest(apache::thrift::FragileConstructor, std::string txn_hash__arg);
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  SendTransactionRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    SendTransactionRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    txn_hash = arg.move();
    __isset.txn_hash = true;
  }

  SendTransactionRequest(SendTransactionRequest&&) = default;

  SendTransactionRequest(const SendTransactionRequest&) = default;

  SendTransactionRequest& operator=(SendTransactionRequest&&) = default;

  SendTransactionRequest& operator=(const SendTransactionRequest&) = default;
  void __clear();
  std::string txn_hash;

  struct __isset {
    bool txn_hash;
  } __isset = {};
  bool operator==(const SendTransactionRequest& rhs) const;

  bool operator < (const SendTransactionRequest& rhs) const {
    if (!(txn_hash == rhs.txn_hash)) {
      return txn_hash < rhs.txn_hash;
    }
    (void)rhs;
    return false;
  }

  const std::string& get_txn_hash() const& {
    return txn_hash;
  }

  std::string get_txn_hash() && {
    return std::move(txn_hash);
  }

  template <typename T_SendTransactionRequest_txn_hash_struct_setter = std::string>
  std::string& set_txn_hash(T_SendTransactionRequest_txn_hash_struct_setter&& txn_hash_) {
    txn_hash = std::forward<T_SendTransactionRequest_txn_hash_struct_setter>(txn_hash_);
    __isset.txn_hash = true;
    return txn_hash;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  static void translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype);

  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< SendTransactionRequest >;
};

void swap(SendTransactionRequest& a, SendTransactionRequest& b);
extern template void SendTransactionRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t SendTransactionRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t SendTransactionRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t SendTransactionRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void SendTransactionRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t SendTransactionRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t SendTransactionRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t SendTransactionRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

template <class Protocol_>
uint32_t SendTransactionRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}} // node::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::node::cpp2::SendTransactionRequest>::clear( ::node::cpp2::SendTransactionRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::node::cpp2::SendTransactionRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::node::cpp2::SendTransactionRequest>::write(Protocol* proto,  ::node::cpp2::SendTransactionRequest const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> void Cpp2Ops< ::node::cpp2::SendTransactionRequest>::read(Protocol* proto,  ::node::cpp2::SendTransactionRequest* obj) {
  return obj->readNoXfer(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::node::cpp2::SendTransactionRequest>::serializedSize(Protocol const* proto,  ::node::cpp2::SendTransactionRequest const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::node::cpp2::SendTransactionRequest>::serializedSizeZC(Protocol const* proto,  ::node::cpp2::SendTransactionRequest const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace node { namespace cpp2 {
class SendTransactionResponse final : private apache::thrift::detail::st::ComparisonOperators<SendTransactionResponse> {
 public:

  SendTransactionResponse() {}
  // FragileConstructor for use in initialization lists only.
  SendTransactionResponse(apache::thrift::FragileConstructor,  ::node::cpp2::Transaction txn__arg,  ::node::cpp2::ErrorStruct error__arg);
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  SendTransactionResponse(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    SendTransactionResponse(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    txn = arg.move();
    __isset.txn = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  SendTransactionResponse(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    SendTransactionResponse(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    error = arg.move();
    __isset.error = true;
  }

  SendTransactionResponse(SendTransactionResponse&&) = default;

  SendTransactionResponse(const SendTransactionResponse&) = default;

  SendTransactionResponse& operator=(SendTransactionResponse&&) = default;

  SendTransactionResponse& operator=(const SendTransactionResponse&) = default;
  void __clear();
   ::node::cpp2::Transaction txn;
   ::node::cpp2::ErrorStruct error;

  struct __isset {
    bool txn;
    bool error;
  } __isset = {};
  bool operator==(const SendTransactionResponse& rhs) const;

  bool operator < (const SendTransactionResponse& rhs) const {
    if (!(txn == rhs.txn)) {
      return txn < rhs.txn;
    }
    if (!(error == rhs.error)) {
      return error < rhs.error;
    }
    (void)rhs;
    return false;
  }
  const  ::node::cpp2::Transaction& get_txn() const&;
   ::node::cpp2::Transaction get_txn() &&;

  template <typename T_SendTransactionResponse_txn_struct_setter =  ::node::cpp2::Transaction>
   ::node::cpp2::Transaction& set_txn(T_SendTransactionResponse_txn_struct_setter&& txn_) {
    txn = std::forward<T_SendTransactionResponse_txn_struct_setter>(txn_);
    __isset.txn = true;
    return txn;
  }
  const  ::node::cpp2::ErrorStruct& get_error() const&;
   ::node::cpp2::ErrorStruct get_error() &&;

  template <typename T_SendTransactionResponse_error_struct_setter =  ::node::cpp2::ErrorStruct>
   ::node::cpp2::ErrorStruct& set_error(T_SendTransactionResponse_error_struct_setter&& error_) {
    error = std::forward<T_SendTransactionResponse_error_struct_setter>(error_);
    __isset.error = true;
    return error;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  static void translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype);

  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< SendTransactionResponse >;
};

void swap(SendTransactionResponse& a, SendTransactionResponse& b);
extern template void SendTransactionResponse::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t SendTransactionResponse::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t SendTransactionResponse::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t SendTransactionResponse::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void SendTransactionResponse::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t SendTransactionResponse::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t SendTransactionResponse::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t SendTransactionResponse::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

template <class Protocol_>
uint32_t SendTransactionResponse::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}} // node::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::node::cpp2::SendTransactionResponse>::clear( ::node::cpp2::SendTransactionResponse* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::node::cpp2::SendTransactionResponse>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::node::cpp2::SendTransactionResponse>::write(Protocol* proto,  ::node::cpp2::SendTransactionResponse const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> void Cpp2Ops< ::node::cpp2::SendTransactionResponse>::read(Protocol* proto,  ::node::cpp2::SendTransactionResponse* obj) {
  return obj->readNoXfer(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::node::cpp2::SendTransactionResponse>::serializedSize(Protocol const* proto,  ::node::cpp2::SendTransactionResponse const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::node::cpp2::SendTransactionResponse>::serializedSizeZC(Protocol const* proto,  ::node::cpp2::SendTransactionResponse const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace node { namespace cpp2 {
class NotifyNewInventoryRequest final : private apache::thrift::detail::st::ComparisonOperators<NotifyNewInventoryRequest> {
 public:

  NotifyNewInventoryRequest() {}
  // FragileConstructor for use in initialization lists only.
  NotifyNewInventoryRequest(apache::thrift::FragileConstructor, std::string inv_item_hash__arg);
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  NotifyNewInventoryRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    NotifyNewInventoryRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    inv_item_hash = arg.move();
    __isset.inv_item_hash = true;
  }

  NotifyNewInventoryRequest(NotifyNewInventoryRequest&&) = default;

  NotifyNewInventoryRequest(const NotifyNewInventoryRequest&) = default;

  NotifyNewInventoryRequest& operator=(NotifyNewInventoryRequest&&) = default;

  NotifyNewInventoryRequest& operator=(const NotifyNewInventoryRequest&) = default;
  void __clear();
  std::string inv_item_hash;

  struct __isset {
    bool inv_item_hash;
  } __isset = {};
  bool operator==(const NotifyNewInventoryRequest& rhs) const;

  bool operator < (const NotifyNewInventoryRequest& rhs) const {
    if (!(inv_item_hash == rhs.inv_item_hash)) {
      return inv_item_hash < rhs.inv_item_hash;
    }
    (void)rhs;
    return false;
  }

  const std::string& get_inv_item_hash() const& {
    return inv_item_hash;
  }

  std::string get_inv_item_hash() && {
    return std::move(inv_item_hash);
  }

  template <typename T_NotifyNewInventoryRequest_inv_item_hash_struct_setter = std::string>
  std::string& set_inv_item_hash(T_NotifyNewInventoryRequest_inv_item_hash_struct_setter&& inv_item_hash_) {
    inv_item_hash = std::forward<T_NotifyNewInventoryRequest_inv_item_hash_struct_setter>(inv_item_hash_);
    __isset.inv_item_hash = true;
    return inv_item_hash;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  static void translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype);

  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< NotifyNewInventoryRequest >;
};

void swap(NotifyNewInventoryRequest& a, NotifyNewInventoryRequest& b);
extern template void NotifyNewInventoryRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t NotifyNewInventoryRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t NotifyNewInventoryRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t NotifyNewInventoryRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void NotifyNewInventoryRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t NotifyNewInventoryRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t NotifyNewInventoryRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t NotifyNewInventoryRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

template <class Protocol_>
uint32_t NotifyNewInventoryRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}} // node::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::node::cpp2::NotifyNewInventoryRequest>::clear( ::node::cpp2::NotifyNewInventoryRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::node::cpp2::NotifyNewInventoryRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::node::cpp2::NotifyNewInventoryRequest>::write(Protocol* proto,  ::node::cpp2::NotifyNewInventoryRequest const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> void Cpp2Ops< ::node::cpp2::NotifyNewInventoryRequest>::read(Protocol* proto,  ::node::cpp2::NotifyNewInventoryRequest* obj) {
  return obj->readNoXfer(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::node::cpp2::NotifyNewInventoryRequest>::serializedSize(Protocol const* proto,  ::node::cpp2::NotifyNewInventoryRequest const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::node::cpp2::NotifyNewInventoryRequest>::serializedSizeZC(Protocol const* proto,  ::node::cpp2::NotifyNewInventoryRequest const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace node { namespace cpp2 {
class NotifyNewInventoryResponse final : private apache::thrift::detail::st::ComparisonOperators<NotifyNewInventoryResponse> {
 public:

  NotifyNewInventoryResponse() {}
  // FragileConstructor for use in initialization lists only.
  NotifyNewInventoryResponse(apache::thrift::FragileConstructor,  ::node::cpp2::ErrorStruct error__arg);
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  NotifyNewInventoryResponse(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    NotifyNewInventoryResponse(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    error = arg.move();
    __isset.error = true;
  }

  NotifyNewInventoryResponse(NotifyNewInventoryResponse&&) = default;

  NotifyNewInventoryResponse(const NotifyNewInventoryResponse&) = default;

  NotifyNewInventoryResponse& operator=(NotifyNewInventoryResponse&&) = default;

  NotifyNewInventoryResponse& operator=(const NotifyNewInventoryResponse&) = default;
  void __clear();
   ::node::cpp2::ErrorStruct error;

  struct __isset {
    bool error;
  } __isset = {};
  bool operator==(const NotifyNewInventoryResponse& rhs) const;

  bool operator < (const NotifyNewInventoryResponse& rhs) const {
    if (!(error == rhs.error)) {
      return error < rhs.error;
    }
    (void)rhs;
    return false;
  }
  const  ::node::cpp2::ErrorStruct& get_error() const&;
   ::node::cpp2::ErrorStruct get_error() &&;

  template <typename T_NotifyNewInventoryResponse_error_struct_setter =  ::node::cpp2::ErrorStruct>
   ::node::cpp2::ErrorStruct& set_error(T_NotifyNewInventoryResponse_error_struct_setter&& error_) {
    error = std::forward<T_NotifyNewInventoryResponse_error_struct_setter>(error_);
    __isset.error = true;
    return error;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  static void translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype);

  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< NotifyNewInventoryResponse >;
};

void swap(NotifyNewInventoryResponse& a, NotifyNewInventoryResponse& b);
extern template void NotifyNewInventoryResponse::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t NotifyNewInventoryResponse::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t NotifyNewInventoryResponse::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t NotifyNewInventoryResponse::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void NotifyNewInventoryResponse::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t NotifyNewInventoryResponse::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t NotifyNewInventoryResponse::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t NotifyNewInventoryResponse::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

template <class Protocol_>
uint32_t NotifyNewInventoryResponse::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}} // node::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::node::cpp2::NotifyNewInventoryResponse>::clear( ::node::cpp2::NotifyNewInventoryResponse* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::node::cpp2::NotifyNewInventoryResponse>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::node::cpp2::NotifyNewInventoryResponse>::write(Protocol* proto,  ::node::cpp2::NotifyNewInventoryResponse const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> void Cpp2Ops< ::node::cpp2::NotifyNewInventoryResponse>::read(Protocol* proto,  ::node::cpp2::NotifyNewInventoryResponse* obj) {
  return obj->readNoXfer(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::node::cpp2::NotifyNewInventoryResponse>::serializedSize(Protocol const* proto,  ::node::cpp2::NotifyNewInventoryResponse const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::node::cpp2::NotifyNewInventoryResponse>::serializedSizeZC(Protocol const* proto,  ::node::cpp2::NotifyNewInventoryResponse const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace node { namespace cpp2 {
class GetPeerInfoRequest final : private apache::thrift::detail::st::ComparisonOperators<GetPeerInfoRequest> {
 public:

  GetPeerInfoRequest() :
      requesting_port(0) {}
  // FragileConstructor for use in initialization lists only.
  GetPeerInfoRequest(apache::thrift::FragileConstructor, std::string requesting_host__arg, int32_t requesting_port__arg);
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  GetPeerInfoRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    GetPeerInfoRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    requesting_host = arg.move();
    __isset.requesting_host = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  GetPeerInfoRequest(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    GetPeerInfoRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    requesting_port = arg.move();
    __isset.requesting_port = true;
  }

  GetPeerInfoRequest(GetPeerInfoRequest&&) = default;

  GetPeerInfoRequest(const GetPeerInfoRequest&) = default;

  GetPeerInfoRequest& operator=(GetPeerInfoRequest&&) = default;

  GetPeerInfoRequest& operator=(const GetPeerInfoRequest&) = default;
  void __clear();
  std::string requesting_host;
  int32_t requesting_port;

  struct __isset {
    bool requesting_host;
    bool requesting_port;
  } __isset = {};
  bool operator==(const GetPeerInfoRequest& rhs) const;

  bool operator < (const GetPeerInfoRequest& rhs) const {
    if (!(requesting_host == rhs.requesting_host)) {
      return requesting_host < rhs.requesting_host;
    }
    if (!(requesting_port == rhs.requesting_port)) {
      return requesting_port < rhs.requesting_port;
    }
    (void)rhs;
    return false;
  }

  const std::string& get_requesting_host() const& {
    return requesting_host;
  }

  std::string get_requesting_host() && {
    return std::move(requesting_host);
  }

  template <typename T_GetPeerInfoRequest_requesting_host_struct_setter = std::string>
  std::string& set_requesting_host(T_GetPeerInfoRequest_requesting_host_struct_setter&& requesting_host_) {
    requesting_host = std::forward<T_GetPeerInfoRequest_requesting_host_struct_setter>(requesting_host_);
    __isset.requesting_host = true;
    return requesting_host;
  }

  int32_t get_requesting_port() const {
    return requesting_port;
  }

  int32_t& set_requesting_port(int32_t requesting_port_) {
    requesting_port = requesting_port_;
    __isset.requesting_port = true;
    return requesting_port;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  static void translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype);

  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetPeerInfoRequest >;
};

void swap(GetPeerInfoRequest& a, GetPeerInfoRequest& b);
extern template void GetPeerInfoRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t GetPeerInfoRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t GetPeerInfoRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t GetPeerInfoRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void GetPeerInfoRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t GetPeerInfoRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t GetPeerInfoRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t GetPeerInfoRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

template <class Protocol_>
uint32_t GetPeerInfoRequest::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}} // node::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::node::cpp2::GetPeerInfoRequest>::clear( ::node::cpp2::GetPeerInfoRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::node::cpp2::GetPeerInfoRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::node::cpp2::GetPeerInfoRequest>::write(Protocol* proto,  ::node::cpp2::GetPeerInfoRequest const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> void Cpp2Ops< ::node::cpp2::GetPeerInfoRequest>::read(Protocol* proto,  ::node::cpp2::GetPeerInfoRequest* obj) {
  return obj->readNoXfer(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::node::cpp2::GetPeerInfoRequest>::serializedSize(Protocol const* proto,  ::node::cpp2::GetPeerInfoRequest const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::node::cpp2::GetPeerInfoRequest>::serializedSizeZC(Protocol const* proto,  ::node::cpp2::GetPeerInfoRequest const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace node { namespace cpp2 {
class GetPeerInfoResponse final : private apache::thrift::detail::st::ComparisonOperators<GetPeerInfoResponse> {
 public:

  GetPeerInfoResponse() :
      port(0),
      protocol_version(0) {}
  // FragileConstructor for use in initialization lists only.
  GetPeerInfoResponse(apache::thrift::FragileConstructor, std::string host__arg, int32_t port__arg, int32_t protocol_version__arg,  ::node::cpp2::ErrorStruct error__arg);
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  GetPeerInfoResponse(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    GetPeerInfoResponse(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    host = arg.move();
    __isset.host = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  GetPeerInfoResponse(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    GetPeerInfoResponse(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    port = arg.move();
    __isset.port = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  GetPeerInfoResponse(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    GetPeerInfoResponse(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    protocol_version = arg.move();
    __isset.protocol_version = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  GetPeerInfoResponse(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    GetPeerInfoResponse(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    error = arg.move();
    __isset.error = true;
  }

  GetPeerInfoResponse(GetPeerInfoResponse&&) = default;

  GetPeerInfoResponse(const GetPeerInfoResponse&) = default;

  GetPeerInfoResponse& operator=(GetPeerInfoResponse&&) = default;

  GetPeerInfoResponse& operator=(const GetPeerInfoResponse&) = default;
  void __clear();
  std::string host;
  int32_t port;
  int32_t protocol_version;
   ::node::cpp2::ErrorStruct error;

  struct __isset {
    bool host;
    bool port;
    bool protocol_version;
    bool error;
  } __isset = {};
  bool operator==(const GetPeerInfoResponse& rhs) const;

  bool operator < (const GetPeerInfoResponse& rhs) const {
    if (!(host == rhs.host)) {
      return host < rhs.host;
    }
    if (!(port == rhs.port)) {
      return port < rhs.port;
    }
    if (!(protocol_version == rhs.protocol_version)) {
      return protocol_version < rhs.protocol_version;
    }
    if (!(error == rhs.error)) {
      return error < rhs.error;
    }
    (void)rhs;
    return false;
  }

  const std::string& get_host() const& {
    return host;
  }

  std::string get_host() && {
    return std::move(host);
  }

  template <typename T_GetPeerInfoResponse_host_struct_setter = std::string>
  std::string& set_host(T_GetPeerInfoResponse_host_struct_setter&& host_) {
    host = std::forward<T_GetPeerInfoResponse_host_struct_setter>(host_);
    __isset.host = true;
    return host;
  }

  int32_t get_port() const {
    return port;
  }

  int32_t& set_port(int32_t port_) {
    port = port_;
    __isset.port = true;
    return port;
  }

  int32_t get_protocol_version() const {
    return protocol_version;
  }

  int32_t& set_protocol_version(int32_t protocol_version_) {
    protocol_version = protocol_version_;
    __isset.protocol_version = true;
    return protocol_version;
  }
  const  ::node::cpp2::ErrorStruct& get_error() const&;
   ::node::cpp2::ErrorStruct get_error() &&;

  template <typename T_GetPeerInfoResponse_error_struct_setter =  ::node::cpp2::ErrorStruct>
   ::node::cpp2::ErrorStruct& set_error(T_GetPeerInfoResponse_error_struct_setter&& error_) {
    error = std::forward<T_GetPeerInfoResponse_error_struct_setter>(error_);
    __isset.error = true;
    return error;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  static void translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype);

  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< GetPeerInfoResponse >;
};

void swap(GetPeerInfoResponse& a, GetPeerInfoResponse& b);
extern template void GetPeerInfoResponse::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t GetPeerInfoResponse::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t GetPeerInfoResponse::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t GetPeerInfoResponse::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void GetPeerInfoResponse::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t GetPeerInfoResponse::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t GetPeerInfoResponse::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t GetPeerInfoResponse::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

template <class Protocol_>
uint32_t GetPeerInfoResponse::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}} // node::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::node::cpp2::GetPeerInfoResponse>::clear( ::node::cpp2::GetPeerInfoResponse* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::node::cpp2::GetPeerInfoResponse>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::node::cpp2::GetPeerInfoResponse>::write(Protocol* proto,  ::node::cpp2::GetPeerInfoResponse const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> void Cpp2Ops< ::node::cpp2::GetPeerInfoResponse>::read(Protocol* proto,  ::node::cpp2::GetPeerInfoResponse* obj) {
  return obj->readNoXfer(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::node::cpp2::GetPeerInfoResponse>::serializedSize(Protocol const* proto,  ::node::cpp2::GetPeerInfoResponse const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::node::cpp2::GetPeerInfoResponse>::serializedSizeZC(Protocol const* proto,  ::node::cpp2::GetPeerInfoResponse const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
