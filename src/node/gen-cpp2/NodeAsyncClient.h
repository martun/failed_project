/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <folly/futures/Future.h>
#include <thrift/lib/cpp/TApplicationException.h>
#include <thrift/lib/cpp2/async/AsyncClient.h>
#include <thrift/lib/cpp2/async/FutureRequest.h>
#include "node/gen-cpp2/node_types.h"

namespace folly {
  class IOBuf;
  class IOBufQueue;
}
namespace apache { namespace thrift {
  class Cpp2RequestContext;
  class BinaryProtocolReader;
  class CompactProtocolReader;
  namespace transport { class THeader; }
}}

namespace node { namespace cpp2 {

class NodeAsyncClient : public apache::thrift::GeneratedAsyncClient {
 public:
  using apache::thrift::GeneratedAsyncClient::GeneratedAsyncClient;

  char const* getServiceName() const noexcept override {
    return "Node";
  }

  virtual void notify_new_inventory_hash(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::node::cpp2::NotifyNewInventoryRequest& request);
  virtual void notify_new_inventory_hash(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::node::cpp2::NotifyNewInventoryRequest& request);
 private:
  virtual void notify_new_inventory_hashImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::node::cpp2::NotifyNewInventoryRequest& request);
 public:
  virtual void sync_notify_new_inventory_hash( ::node::cpp2::NotifyNewInventoryResponse& _return, const  ::node::cpp2::NotifyNewInventoryRequest& request);
  virtual void sync_notify_new_inventory_hash(apache::thrift::RpcOptions& rpcOptions,  ::node::cpp2::NotifyNewInventoryResponse& _return, const  ::node::cpp2::NotifyNewInventoryRequest& request);
  virtual folly::Future< ::node::cpp2::NotifyNewInventoryResponse> future_notify_new_inventory_hash(const  ::node::cpp2::NotifyNewInventoryRequest& request);
  virtual folly::SemiFuture< ::node::cpp2::NotifyNewInventoryResponse> semifuture_notify_new_inventory_hash(const  ::node::cpp2::NotifyNewInventoryRequest& request);
  virtual folly::Future< ::node::cpp2::NotifyNewInventoryResponse> future_notify_new_inventory_hash(apache::thrift::RpcOptions& rpcOptions, const  ::node::cpp2::NotifyNewInventoryRequest& request);
  virtual folly::SemiFuture< ::node::cpp2::NotifyNewInventoryResponse> semifuture_notify_new_inventory_hash(apache::thrift::RpcOptions& rpcOptions, const  ::node::cpp2::NotifyNewInventoryRequest& request);
  virtual folly::Future<std::pair< ::node::cpp2::NotifyNewInventoryResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_notify_new_inventory_hash(apache::thrift::RpcOptions& rpcOptions, const  ::node::cpp2::NotifyNewInventoryRequest& request);
  virtual folly::SemiFuture<std::pair< ::node::cpp2::NotifyNewInventoryResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_notify_new_inventory_hash(apache::thrift::RpcOptions& rpcOptions, const  ::node::cpp2::NotifyNewInventoryRequest& request);
  virtual void notify_new_inventory_hash(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::node::cpp2::NotifyNewInventoryRequest& request);
  static folly::exception_wrapper recv_wrapped_notify_new_inventory_hash( ::node::cpp2::NotifyNewInventoryResponse& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_notify_new_inventory_hash( ::node::cpp2::NotifyNewInventoryResponse& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_notify_new_inventory_hash( ::node::cpp2::NotifyNewInventoryResponse& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_notify_new_inventory_hash( ::node::cpp2::NotifyNewInventoryResponse& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void notify_new_inventory_hashT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::node::cpp2::NotifyNewInventoryRequest& request);
 public:
  virtual void send_transaction(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::node::cpp2::SendTransactionRequest& request);
  virtual void send_transaction(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::node::cpp2::SendTransactionRequest& request);
 private:
  virtual void send_transactionImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::node::cpp2::SendTransactionRequest& request);
 public:
  virtual void sync_send_transaction( ::node::cpp2::SendTransactionResponse& _return, const  ::node::cpp2::SendTransactionRequest& request);
  virtual void sync_send_transaction(apache::thrift::RpcOptions& rpcOptions,  ::node::cpp2::SendTransactionResponse& _return, const  ::node::cpp2::SendTransactionRequest& request);
  virtual folly::Future< ::node::cpp2::SendTransactionResponse> future_send_transaction(const  ::node::cpp2::SendTransactionRequest& request);
  virtual folly::SemiFuture< ::node::cpp2::SendTransactionResponse> semifuture_send_transaction(const  ::node::cpp2::SendTransactionRequest& request);
  virtual folly::Future< ::node::cpp2::SendTransactionResponse> future_send_transaction(apache::thrift::RpcOptions& rpcOptions, const  ::node::cpp2::SendTransactionRequest& request);
  virtual folly::SemiFuture< ::node::cpp2::SendTransactionResponse> semifuture_send_transaction(apache::thrift::RpcOptions& rpcOptions, const  ::node::cpp2::SendTransactionRequest& request);
  virtual folly::Future<std::pair< ::node::cpp2::SendTransactionResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_send_transaction(apache::thrift::RpcOptions& rpcOptions, const  ::node::cpp2::SendTransactionRequest& request);
  virtual folly::SemiFuture<std::pair< ::node::cpp2::SendTransactionResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_send_transaction(apache::thrift::RpcOptions& rpcOptions, const  ::node::cpp2::SendTransactionRequest& request);
  virtual void send_transaction(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::node::cpp2::SendTransactionRequest& request);
  static folly::exception_wrapper recv_wrapped_send_transaction( ::node::cpp2::SendTransactionResponse& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_send_transaction( ::node::cpp2::SendTransactionResponse& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_send_transaction( ::node::cpp2::SendTransactionResponse& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_send_transaction( ::node::cpp2::SendTransactionResponse& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void send_transactionT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::node::cpp2::SendTransactionRequest& request);
 public:
  virtual void get_peer(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::node::cpp2::GetPeerInfoRequest& request);
  virtual void get_peer(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::node::cpp2::GetPeerInfoRequest& request);
 private:
  virtual void get_peerImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::node::cpp2::GetPeerInfoRequest& request);
 public:
  virtual void sync_get_peer( ::node::cpp2::GetPeerInfoResponse& _return, const  ::node::cpp2::GetPeerInfoRequest& request);
  virtual void sync_get_peer(apache::thrift::RpcOptions& rpcOptions,  ::node::cpp2::GetPeerInfoResponse& _return, const  ::node::cpp2::GetPeerInfoRequest& request);
  virtual folly::Future< ::node::cpp2::GetPeerInfoResponse> future_get_peer(const  ::node::cpp2::GetPeerInfoRequest& request);
  virtual folly::SemiFuture< ::node::cpp2::GetPeerInfoResponse> semifuture_get_peer(const  ::node::cpp2::GetPeerInfoRequest& request);
  virtual folly::Future< ::node::cpp2::GetPeerInfoResponse> future_get_peer(apache::thrift::RpcOptions& rpcOptions, const  ::node::cpp2::GetPeerInfoRequest& request);
  virtual folly::SemiFuture< ::node::cpp2::GetPeerInfoResponse> semifuture_get_peer(apache::thrift::RpcOptions& rpcOptions, const  ::node::cpp2::GetPeerInfoRequest& request);
  virtual folly::Future<std::pair< ::node::cpp2::GetPeerInfoResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_future_get_peer(apache::thrift::RpcOptions& rpcOptions, const  ::node::cpp2::GetPeerInfoRequest& request);
  virtual folly::SemiFuture<std::pair< ::node::cpp2::GetPeerInfoResponse, std::unique_ptr<apache::thrift::transport::THeader>>> header_semifuture_get_peer(apache::thrift::RpcOptions& rpcOptions, const  ::node::cpp2::GetPeerInfoRequest& request);
  virtual void get_peer(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::node::cpp2::GetPeerInfoRequest& request);
  static folly::exception_wrapper recv_wrapped_get_peer( ::node::cpp2::GetPeerInfoResponse& _return, ::apache::thrift::ClientReceiveState& state);
  static void recv_get_peer( ::node::cpp2::GetPeerInfoResponse& _return, ::apache::thrift::ClientReceiveState& state);
  // Mock friendly virtual instance method
  virtual void recv_instance_get_peer( ::node::cpp2::GetPeerInfoResponse& _return, ::apache::thrift::ClientReceiveState& state);
  virtual folly::exception_wrapper recv_instance_wrapped_get_peer( ::node::cpp2::GetPeerInfoResponse& _return, ::apache::thrift::ClientReceiveState& state);
 private:
  template <typename Protocol_>
  void get_peerT(Protocol_* prot, bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::node::cpp2::GetPeerInfoRequest& request);
 public:
};

}} // node::cpp2
